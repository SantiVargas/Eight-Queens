program Queens;

//{$DEFINE Lape}

Type
  {$IFDEF SIMBA}
  T3DIntegerArray = Array of T2DIntegerArray;
  {$ELSE}
  {$ENDIF}
  T4DIntegerArray = Array of T3DIntegerArray;

var
  Timer: Integer;

Procedure RemovePosInArr(Position: Integer; var Arr: TIntegerArray);

var
  TmpArr: TIntegerArray;
  I: Integer;

begin
  TmpArr := [];
  for I := 0 to High(Arr) do
    if I <> Position then
    begin
      SetLength(TmpArr, Length(TmpArr) + 1);
      TmpArr[High(TmpArr)] := Arr[I];
    end;

  Arr := TmpArr;
end;

Procedure RemoveValInArr(Value: Integer; var A: TIntegerArray);

var
  I: Integer;

begin
  for I := 0 to High(A) do
    if A[I] = Value then
    begin
      RemovePosInArr(I, A);
      I := I - 1;
    end;
end;

Function BCheck(TheBoard: TIntegerArray): TIntegerArray;

var
  Queen, I: integer;

begin
  {$IFDEF Lape}
  Result := [0..63];
  {$ELSE}
  SetLength(Result, 64);
  for I := 0 to High(Result) do
    Result[I] := I;
  {$ENDIF}
  for Queen := 0 to High(TheBoard) do
  begin

    {Row}

    I := TheBoard[Queen];
    Inc(I);

    // Right
    while (I < 64) and ((I mod 8) <> 0) do
    begin
      RemoveValInArr(I, Result);
      Inc(I);
    end;

    I := TheBoard[Queen];
    Dec(I);

    // Left
    while (I >= 0) and ((I mod 8) <> 7) do
    begin
      RemoveValInArr(I, Result);
      Dec(I);
    end;

    {Column}

    I := TheBoard[Queen];

    while (I > 7) do
      {$IFDEF Lape}
      I =- 8;
      {$ELSE}
      I := I - 8;
      {$ENDIF}


    while (I < 64) do
    begin
      if I <> TheBoard[Queen] then
        RemoveValInArr(I, Result);
      IncEx(I, 8);
    end;

    {Diagonal}

    I := TheBoard[Queen];

    // Up, Right
    while (I < 64) and ((I = 0) xor ((I mod 8) <> 0)) do
    begin
      IncEx(I, 9);
      RemoveValInArr(I, Result);
    end;

    I := TheBoard[Queen];

    // Down, Left
    while (I > 0) and ((I mod 8) <> 7) do
    begin
      DecEx(I, 9);
      RemoveValInArr(I, Result);
    end;

    I := TheBoard[Queen];

    // Up, Left
    while (I < 64) and ((I mod 8) <> 7) do
    begin
      IncEx(I, 7);
      RemoveValInArr(I, Result);
    end;

    I := TheBoard[Queen];

    // Down, Right
    while (I > 0) and ((I mod 8) <> 7) do
    begin
      DecEx(I, 7);
      RemoveValInArr(I, Result);
    end;
  end;
end;

procedure CopyIntArr(const Src: TIntegerArray; out Dest: TIntegerArray);
var
  I, H: LongInt;
begin
  H := Length(Src);
  SetLength(Dest, H);
  Dec(H);
  for I := 0 to H do
    Dest[I] := Src[I];
end;

procedure Copy2DIntArr(const Src: T2DIntegerArray; out Dest: T2DIntegerArray);
var
  I, H: LongInt;
begin
  H := Length(Src);
  SetLength(Dest, H);
  Dec(H);
  for I := 0 to H do
    CopyIntArr(Src[I], Dest[I]);
end;

procedure Copy3DIntArr(const Src: T3DIntegerArray; out Dest: T3DIntegerArray);
var
  I, H: LongInt;
begin
  H := Length(Src);
  SetLength(Dest, H);
  Dec(H);
  for I := 0 to H do
    Copy2DIntArr(Src[I], Dest[I]);
end;

Procedure Main;

var
  Board, Bad: TIntegerArray;
  BArray: T2DIntegerArray;
  B2DArray: T3DIntegerArray;
  B3DArray: T4DIntegerArray;
  Index, Queen, X, I, I2: integer;

begin
  for Queen := 0 to 0 do
  case Queen of
    0:
    begin
      Writeln('Queen ' + ToStr(Queen));
      for x := 0 to 0 do //Only working on [0] for now.  0 to 7
      begin
        SetLength(Board, 1);
        Board[Queen] := 30;
        Bad := BCheck(Board);
        Writeln(Bad);
      end;
      Writeln(ToStr(GetTickCount - Timer) + 'ms');
    end;

    1:
    begin
      Writeln('Queen ' + ToStr(Queen));
      for x := 0 to 63 do
      if Board[x] = 0 then
      begin
        Setlength(BArray, Length(BArray) + 1);
        index := High(BArray);
        CopyIntArr(Board, BArray[index]);
        BArray[index][x] := 1;
        //ColumnRowCheck(BArray[index]);
        //DiagonalCheck(BArray[index]);
      end;
      Writeln(ToStr(GetTickCount - Timer) + 'ms');
    end;

    2:
    begin
      //SetLength(Board,0);
      Writeln('Queen ' + ToStr(Queen));
      for I := 0 to High(BArray) do
        for x := 0 to 63 do
        if BArray[I][x] = 0 then
        begin
          Setlength(B2DArray, Length(B2DArray) + 1);
          Index := High(B2DArray);
          Copy2DIntArr(BArray, B2DArray[Index]);
          B2DArray[Index][I][x] := 1;
          //ColumnRowCheck(B2DArray[Index][I]);
          //DiagonalCheck(B2DArray[Index][I]);
        end;
      Writeln(ToStr(GetTickCount - Timer) + 'ms');
    end;

    3:
    begin
      //SetLength(BArray,0);
      Writeln('Queen ' + ToStr(Queen));
      for I2 := 0 to High(B2DArray) do
      begin
        for I := 0 to High(B2DArray[I]) do
          for x := 0 to 63 do
          if B2DArray[I2][I][x] = 0 then
          begin
            Setlength(B3DArray, Length(B3DArray) + 1);
            Index := High(B3DArray);
            Copy3DIntArr(B2DArray, B3DArray[Index]);
            B3DArray[Index][I2][I][x] := 1;
            //ColumnRowCheck(B3DArray[Index][I2][I]);
            //DiagonalCheck(B3DArray[Index][I2][I]);
          end;
        SetLength(B2DArray[I2],0);
      end;
      Writeln(ToStr(GetTickCount - Timer) + 'ms');
    end;
  end;
end;

begin
  //ClearDebug;
  Timer := GetTickCount;
  Main;
end.
